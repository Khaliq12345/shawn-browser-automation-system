# --- Stage 1: Builder ---
# Use a Node image for building
FROM node:22-alpine AS builder

# Set the working directory
WORKDIR /app

# Copy package.json and package-lock.json to install dependencies
# We do this first to leverage Docker's layer caching
COPY interface/package.json interface/package-lock.json ./

# Install dependencies
RUN npm install

# Copy the rest of the application source code
# Assuming your source code is in a directory named 'interface'
COPY interface ./interface


WORKDIR /app/interface

# Run the build command
# The build output is typically placed inside the 'interface' directory or /app/.output
# Adjust the build command path if needed
RUN npm run build


# --- Stage 2: Production Runtime ---
# Use a clean, smaller Node image for the final runtime
FROM node:22-alpine AS production

# Set the working directory
WORKDIR /app

# If your 'npm run build' generates output into '/app/interface/.output' in the builder stage:
COPY --from=builder /app/interface/.output ./interface/.output

# Expose the port the app runs on (matching your docker-compose)
EXPOSE 3000

# Set the environment (optional, but good practice for node apps)
ENV NODE_ENV production

# Your existing command to start the application
CMD [ "node", "./interface/.output/server/index.mjs" ]
